---
title: One Way Anova with a random effect
author: "[Julian Faraway](https://julianfaraway.github.io/)"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  github_document:
    toc: true
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(comment=NA, 
                      echo = TRUE,
                      fig.path="figs/",
                      dev = 'svglite',  
                      fig.ext = ".svg",
                      warning=FALSE, 
                      message=FALSE)
ggplot2::theme_set(ggplot2::theme_bw())
par(mgp=c(1.5,0.5,0), mar=c(3.1,3.1,0.1,0), pch=20)
```

See the [introduction](index.md) for an overview. 

This example is discussed in more detail in my book
[Extending the Linear Model with R](https://julianfaraway.github.io/faraway/ELM/)

Required libraries:

```{r}
library(faraway)
library(ggplot2)
library(lme4)
library(INLA)
library(knitr)
```

# Data

Load up and look at the data, which concerns the brightness of paper
which may vary between operators of the production machinery.

```{r pulpdat}
data(pulp, package="faraway")
summary(pulp)
ggplot(pulp, aes(x=operator, y=bright))+geom_point(position = position_jitter(width=0.1, height=0.0))
```

You can read more about the data by typing `help(pulp)` at the R prompt.

In this example, there are only five replicates per level. There is
no strong reason to reject the normality assumption. We don't care
about the specific operators, who are named a, b, c and d, but we do
want to know how they vary.

# Likelihood inference

We use a model of the form:
$$y_{ij} = \mu + \alpha_i + \epsilon_{ij} \qquad i=1,\dots ,a
  \qquad j=1,\dots ,n_i,$$ where the $\alpha_i$ and $\epsilon_{ij}$s are normal
with mean zero, but variances $\sigma_\alpha^2$ and $\sigma^2_\epsilon$,
respectively. 

The default fit uses the REML estimation method:

```{r}
mmod <- lmer(bright ~ 1+(1|operator), pulp)
faraway::sumary(mmod)
```

We see slightly less variation within operators (SD=0.261) than between
operators (SD=0.326). 

## Hypothesis testing

We can also use the ML method:

```{r}
smod <- lmer(bright ~ 1+(1|operator), pulp, REML = FALSE)
faraway::sumary(smod)
```

The REML method is preferred for estimation but we must use the ML method if we wish
to make hypothesis tests comparing models.

If we want to test for variation between operators, we fit a null model
containing no operator, compute the likelihood ratio statistic and corresponding
p-value:

```{r}
nullmod <- lm(bright ~ 1, pulp)
lrtstat <- as.numeric(2*(logLik(smod)-logLik(nullmod)))
pvalue <- pchisq(lrtstat,1,lower=FALSE)
data.frame(lrtstat, pvalue)
```

Superficially, the p-value greater than 0.05 suggests no strong evidence
against that hypothesis that there is no variation among the operators. But
there is good reason to doubt the chi-squared null distribution when
testing parameter on the boundary of the space (as we do here at zero). A
parametric bootstrap can be used where we generate samples from the null
and compute the test statistic repeatedly:

```{r pulpparaboot, cache=TRUE}
lrstat <- numeric(1000)
set.seed(123)
for(i in 1:1000){
   y <- unlist(simulate(nullmod))
   bnull <- lm(y ~ 1)
   balt <- lmer(y ~ 1 + (1|operator), pulp, REML=FALSE)
   lrstat[i] <- as.numeric(2*(logLik(balt)-logLik(bnull)))
  }
```

Check the proportion of simulated test statistics that are close to zero:

```{r}
mean(lrstat < 0.00001)
```

Clearly, the test statistic does not have a chi-squared distribution under
the null. We can compute the proportion that exceed the observed test
statistic of 2.5684:

```{r}
mean(lrstat > 2.5684)
```

This is a more reliable p-value for our hypothesis test which suggest there
is good reason to reject the null hypothesis of no variation between operators.

More sophisticated methods of inference are discussed in 
[Extending the Linear Model with R](https://julianfaraway.github.io/faraway/ELM/)

## Confidence intervals

We can use bootstrap again to compute confidence intervals for
the parameters of interest:

```{r}
confint(mmod, method="boot")
```

We see that the lower end of the confidence interval for the operator SD
extends to zero.

## Random effects

Even though we are most interested in the variation between operators,
we can still estimate their individual effects:

```{r}
ranef(mmod)$operator
```

Approximate 95% confidence intervals can be displayed with:

```{r pulpebar}
dd = as.data.frame(ranef(mmod))
ggplot(dd, aes(y=grp,x=condval)) +
        geom_point() +
        geom_errorbarh(aes(xmin=condval -2*condsd,
                           xmax=condval +2*condsd), height=0)
```

# INLA

Integrated nested Laplace approximation is a method of Bayesian computation
which uses approximation rather than simulation. More can be found
on this topic in [Bayesian Regression Modeling with INLA](http://julianfaraway.github.io/brinla/) and the 
[chapter on GLMMs](https://julianfaraway.github.io/brinlabook/chaglmm.html)

Use the most recent computational methodology:


```{r}
inla.setOption(inla.mode="experimental")
inla.setOption("short.summary",TRUE)
```

Run the INLA model with default priors:

```{r pulpinladefault, cache=TRUE}
imod <- inla(bright ~ f(operator, model="iid"),
             family="gaussian",
             data=pulp)
```

The summary of the posterior distribution for the fixed effects (which is only the intercept in this example):

```{r}
imod$summary.fixed |> kable()
```

The posterior mean is the same as the (RE)ML estimate. The posterior distribution
of the hyperparameters (precision of the error and operator terms)


```{r}
imod$summary.hyperpar |> kable()
```
Precision for the operator term is unreasonably high. This implies
a strong belief that there is no variation between the operators which we would find hard to believe. This is due to the default diffuse gamma prior on the precisions
which put almost all the weight on the error variation and not nearly enough on
the operator variation. We need to change the prior.

## Halfnormal prior on the SDs

We try a halfnormal prior with low precision instead. A precision of 0.01 corresponds to an SD of 10. (It is possible to vary the mean but we have set this to 
zero to achieve a halfnormal distribution). 
This is substantially larger than the SD of the response so the information supplied is very weak.

```{r pulpinlatn, cache=TRUE}
tnprior <- list(prec = list(prior="logtnormal", param = c(0,0.01)))
imod <- inla(bright ~ f(operator, model="iid", hyper = tnprior),
               family="gaussian", 
               data=pulp)
summary(imod)
```

The results appear more plausible. Transform to the SD scale 


```{r}
sigmaalpha <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                             imod$internal.marginals.hyperpar[[2]])
sigmaepsilon <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                                imod$internal.marginals.hyperpar[[1]])
```

and output the summary statistics (note that transforming the summary
statistics on the precision scale only works for the quantiles)


```{r}
sigalpha = c(inla.zmarginal(sigmaalpha, silent = TRUE),
            mode=inla.mmarginal(sigmaalpha))
sigepsilon = c(inla.zmarginal(sigmaepsilon, silent = TRUE),
              mode=inla.mmarginal(sigmaepsilon))
rbind(sigalpha, sigepsilon) 
```

The posterior mode is most comparable with the (RE)ML estimates computed
above. In this respect, the results are similar.

We can also get summary statistics on the random effects:

```{r}
imod$summary.random$operator |> kable()
```

Plot the posterior densities for the two SD terms:

```{r plotsdspulp}
ddf <- data.frame(rbind(sigmaalpha,sigmaepsilon),
                  errterm=gl(2,dim(sigmaalpha)[1],labels = c("alpha","epsilon")))
ggplot(ddf, aes(x,y, linetype=errterm))+
  geom_line()+xlab("bright")+ylab("density")+xlim(0,2)
```

We see that the operator SD less precisely known than the error SD. Although
the mode for the operator is smaller, there is a substantial chance it could
be much higher than the error SD.

Is there any variation between operators? We framed this question as an
hypothesis test previously but that is not sensible in this framework. We might
ask the probability that the operator SD is zero. Since we have posited a
continuous prior that places no discrete mass on zero, the posterior probability
will be zero, regardless of the data. Instead we might ask the probability 
that the operator SD is small. Given the response is measured to one decimal
place, 0.1 is a reasonable representation of *small* if we take this to mean
the smallest amount we care about.

We can compute the probability that the operator SD is smaller than 0.1:

```{r}
inla.pmarginal(0.1, sigmaalpha)
```

The probability is small but not entirely negligible.


# Informative gamma priors on the precisions

Now try more informative gamma priors for the precisions. Define it so the mean value of gamma prior is set to the inverse of the
variance of the response. We expect the two error variances to be lower than the response variance so this is an overestimate.
The variance of the gamma prior (for the precision) is controlled by the `apar` shape parameter in the code. `apar=1` is the
exponential distribution. Shape values less than one result in densities that have a mode at zero and decrease monotonely. These
have greater variance and hence less informative.

```{r pulpinlaig, cache=TRUE}
apar <- 0.5
bpar <- var(pulp$bright)*apar
lgprior <- list(prec = list(prior="loggamma", param = c(apar,bpar)))
imod <- inla(bright ~ f(operator, model="iid", hyper = lgprior),
               family="gaussian", 
               data=pulp)
summary(imod)
```

Compute the summaries as before:

```{r}
sigmaalpha <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                             imod$internal.marginals.hyperpar[[2]])
sigmaepsilon <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                            imod$internal.marginals.hyperpar[[1]])
sigalpha = c(inla.zmarginal(sigmaalpha, silent = TRUE),
            mode=inla.mmarginal(sigmaalpha))
sigepsilon = c(inla.zmarginal(sigmaepsilon, silent = TRUE),
              mode=inla.mmarginal(sigmaepsilon))
rbind(sigalpha, sigepsilon) 
```

Slightly different outcome.


Make the plots:
```{r plotsdspulpig}
ddf <- data.frame(rbind(sigmaalpha,sigmaepsilon),
                  errterm=gl(2,dim(sigmaalpha)[1],labels = c("alpha","epsilon")))
ggplot(ddf, aes(x,y, linetype=errterm))+
  geom_line()+xlab("bright")+ylab("density")+xlim(0,2)
```


The posterior for the error SD is quite similar to that seen previously but the operator SD is larger and
bounded away from zero and less dispersed.

We can compute the probability that the operator SD is smaller than 0.1:

```{r}
inla.pmarginal(0.1, sigmaalpha)
```

The probability is very small. The choice of prior may be unsuitable in that no density is placed on
an SD=0 (or infinite precision). We also have very little prior weight on low SD/high precision values. This
leads to a posterior for the operator with very little density assigned to small values of the SD. But we
can see from looking at the data or from prior analyses of the data that there is some possibility that the
operator SD is very small.

# Penalized Complexity Prior

In [Simpson (2017)](https://doi.org/10.1214/16-STS576), penalized complexity priors are proposed. This
requires that we specify a scaling for the SDs of the random effects. We use the SD of the residuals
of the fixed effects only model (what might be called the base model in the paper) to provide this scaling.

```{r pulpinlapc, cache=TRUE}
sdres <- sd(pulp$bright)
pcprior <- list(prec = list(prior="pc.prec", param = c(3*sdres,0.01)))
imod <- inla(bright ~ f(operator, model="iid", hyper = pcprior),
               family="gaussian", 
               data=pulp)
summary(imod)
```

Compute the summaries as before:

```{r}
sigmaalpha <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                             imod$internal.marginals.hyperpar[[2]])
sigmaepsilon <- inla.tmarginal(function(x)1/sqrt(exp(x)),
                            imod$internal.marginals.hyperpar[[1]])
sigalpha = c(inla.zmarginal(sigmaalpha, silent = TRUE),
            mode=inla.mmarginal(sigmaalpha))
sigepsilon = c(inla.zmarginal(sigmaepsilon, silent = TRUE),
              mode=inla.mmarginal(sigmaepsilon))
rbind(sigalpha, sigepsilon) 
```

We get a similar result to the truncated normal prior used earlier although the operator SD is generally smaller.

Make the plots:
```{r plotsdspulppc}
ddf <- data.frame(rbind(sigmaalpha,sigmaepsilon),
                  errterm=gl(2,dim(sigmaalpha)[1],labels = c("alpha","epsilon")))
ggplot(ddf, aes(x,y, linetype=errterm))+
  geom_line()+xlab("bright")+ylab("density")+xlim(0,2)
```

We can compute the probability that the operator SD is smaller than 0.1:

```{r}
inla.pmarginal(0.1, sigmaalpha)
```

The probability is small but not insubstantial.

We can plot the posterior density of $\mu$ along with a 95% credibility interval:

```{r pulpmargfix}
mu <- data.frame(imod$marginals.fixed[[1]])
cbound = inla.qmarginal(c(0.025,0.975),mu)
ggplot(mu, aes(x,y)) + geom_line() + 
  geom_vline(xintercept = cbound) +
  xlab("brightness")+ylab("density")
```

We can plot the posterior marginals of the random effects:

```{r pulprandeffpden}
nlevels = length(unique(pulp$operator))
rdf = data.frame(do.call(rbind,imod$marginals.random$operator))
rdf$operator = gl(nlevels,nrow(rdf)/nlevels,labels=1:nlevels)
ggplot(rdf,aes(x=x,y=y,group=operator, color=operator)) + 
  geom_line() +
  xlab("") + ylab("Density")
```

We see that operators 1 and 2 tend to be lower than 3 and 4. There
is substantial overlap so we would hesitate to declare any difference
between a pair of operators.



# Package version info

```{r}
sessionInfo()
```
