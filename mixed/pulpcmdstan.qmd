---
title: One Way Anova with a random effect using Cmdstan
author: "[Julian Faraway](https://julianfaraway.github.io/)"
date: "`r format(Sys.time(), '%d %B %Y')`"
format: 
  gfm:
    toc: true
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(comment=NA, 
                      echo = TRUE,
                      fig.path="figs/",
                      dev = 'svglite',  
                      fig.ext = ".svg",
                      warning=FALSE, 
                      message=FALSE)
knitr::opts_knit$set(global.par = TRUE)
```

```{r graphopts, include=FALSE}
par(mgp=c(1.5,0.5,0), mar=c(3.1,3.1,0.1,0), pch=20)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r}
library(faraway)
library(cmdstanr)
library(ggplot2)
library(posterior)
register_knitr_engine(override = FALSE)
```

# Data

Load up and look at the data, which concerns the brightness of paper
which may vary between operators of the production machinery.

```{r pulpdat}
data(pulp, package="faraway")
summary(pulp)
ggplot(pulp, aes(x=operator, y=bright))+geom_point(position = position_jitter(width=0.1, height=0.0))
```

# CMDSTAN

STAN chunk will be compiled to 'mod'. Chunk header is:
```
cmdstan, output.var="mod", override = FALSE
```

```{cmdstan, output.var="mod", override = FALSE}
data {
  int<lower=0> N;
  int<lower=0> J;
  array[N] int<lower=1,upper=J> predictor;
  array[N] real response;
}
parameters {
  vector[J] eta;
  real mu;
  real<lower=0> sigmaalpha;
  real<lower=0> sigmaepsilon;
}
transformed parameters {
  vector[J] a;
  vector[N] yhat;

  a = mu + sigmaalpha * eta;

  for (i in 1:N)
    yhat[i] = a[predictor[i]];
}
model {
  eta ~ normal(0, 1);

  response ~ normal(yhat, sigmaepsilon);
}
```


Put the data into a format it can be used:

```{r}
pulpdat <- list(N=nrow(pulp),
                J=length(unique(pulp$operator)),
                response=pulp$bright,
                predictor=as.numeric(pulp$operator))
```

Do the MCMC sampling:

```{r}
fit <- mod$sample(
  data = pulpdat, 
  seed = 123, 
  chains = 4, 
  parallel_chains = 4,
  refresh = 500 # print update every 500 iters
)
```

Get summary on the parameters of interest.

```{r}
fit$summary(c("mu","sigmaalpha","sigmaepsilon","a"))
```

Extract the draws into a convenient dataframe format:

```{r}
draws_df <- fit$draws(format = "df")
```

Check the diagnostics on the most problematic parameter:

```{r cssadiag}
ggplot(draws_df,
       aes(x=.iteration,y=sigmaalpha,color=factor(.chain))) + geom_line() +
  labs(color = 'Chain', x="Iteration")
```

Looks reasonably OK (other parameters less likely to be an issue)


Show posterior densities on the two variance terms:

```{r cspulpvars}
sdf = stack(draws_df[,startsWith(colnames(draws_df),"sigma")])
colnames(sdf) = c("bright","sigma")
levels(sdf$sigma) = c("alpha","epsilon")
ggplot(sdf, aes(x=bright,color=sigma)) + geom_density() + xlim(0,2)
```

Show posteriors on the random effect terms:

```{r cspulpre}
adf = stack(draws_df[,startsWith(colnames(draws_df),"a")])
colnames(adf) = c("bright","operator")
levels(adf$operator) = letters[1:4]
ggplot(adf, aes(x=bright,color=operator)) + geom_density()
```

Compute the lower tail probability.

```{r}
fit$summary("sigmaalpha", tailprob = ~ mean(. <= 0.1))
```

- Results not noticeably different from the rstan version. 
- Previous versions of Stan used `n_eff` while this version uses `ess_bulk`
and `ess_tail`
- Previous version of Stan was rerun with much longer chains because default choice seemed inadequate but this current version is not so bad with the defaul
- Runs faster (much shorter chains) and worked with the most recent version of Stan.
- Seems that cmdstan is a better choice than rstan (but will brms keep up?)








